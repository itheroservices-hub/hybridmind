# HybridMind v1.1 - Premium Upgrade Architecture
**Product Vision:** Transform HybridMind from a single-step AI assistant into an autonomous, multi-model reasoning engine with professional monetization.

---

## EXECUTIVE SUMMARY

**Current State (v1.0):**
- Single-step completions
- 6 commands (explain, review, optimize, tests, fix bugs, quick chat)
- Basic model selection
- Embedded server architecture
- Free, unlimited use

**Target State (v1.1):**
- Agentic multi-step workflows
- Persistent chat interface
- Premium model orchestration
- $19/month Pro tier
- Fast inference optimization
- 128k context windows
- Priority support
- Early access features

**Revenue Model:**
- Free Tier: v1.0 features (basic models, standard speed)
- Pro Tier: $19/month (all premium features)
- Target: 1,000 users = $19k MRR

---

## PHASE 1: CORE ARCHITECTURE (Week 1-2)

### 1.1 Authentication & License System

**Goal:** Verify user subscription status and gate premium features.

**Implementation:**

```typescript
// src/auth/licenseManager.ts
export class LicenseManager {
  private licenseKey: string | null = null;
  private tier: 'free' | 'pro' = 'free';
  private lastVerified: Date | null = null;

  async verifyLicense(key: string): Promise<boolean> {
    // Call license verification API
    const response = await fetch('https://api.hybridmind.dev/v1/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ licenseKey: key })
    });

    const data = await response.json();
    
    if (data.valid && data.tier === 'pro') {
      this.tier = 'pro';
      this.licenseKey = key;
      this.lastVerified = new Date();
      return true;
    }
    
    return false;
  }

  isPro(): boolean {
    return this.tier === 'pro';
  }

  async checkFeatureAccess(feature: string): Promise<boolean> {
    const proFeatures = [
      'agentic-chains',
      'chat-window',
      'premium-models',
      'fast-inference',
      'large-context',
      'priority-support'
    ];

    if (proFeatures.includes(feature)) {
      return this.isPro();
    }

    return true; // Free features
  }
}
```

**Settings Integration:**

```json
// package.json configuration
{
  "hybridmind.licenseKey": {
    "type": "string",
    "default": "",
    "description": "HybridMind Pro license key. Get yours at https://hybridmind.dev"
  },
  "hybridmind.enablePremiumFeatures": {
    "type": "boolean",
    "default": false,
    "description": "Enable Pro features (requires valid license)"
  }
}
```

---

### 1.2 Agentic Chain Engine

**Goal:** Multi-step autonomous execution with context passing.

**Architecture:**

```typescript
// src/agents/chainEngine.ts
export interface ChainStep {
  id: string;
  name: string;
  model: string;
  prompt: string;
  input?: string;
  output?: string;
  status: 'pending' | 'running' | 'complete' | 'failed';
  cost?: number;
  tokens?: number;
  duration?: number;
}

export interface AgenticChain {
  id: string;
  name: string;
  steps: ChainStep[];
  context: Map<string, any>;
  currentStepIndex: number;
}

export class ChainEngine {
  private chains: Map<string, AgenticChain> = new Map();

  async executeChain(chain: AgenticChain, onProgress?: (step: ChainStep) => void): Promise<string> {
    const results: string[] = [];

    for (let i = 0; i < chain.steps.length; i++) {
      const step = chain.steps[i];
      step.status = 'running';
      
      if (onProgress) {
        onProgress(step);
      }

      try {
        const startTime = Date.now();
        
        // Build input from previous step or initial input
        const input = i === 0 
          ? step.input 
          : this.interpolateContext(step.prompt, chain.context);

        // Execute step
        const result = await this.executeStep(step.model, input);
        
        // Update step
        step.output = result.content;
        step.status = 'complete';
        step.tokens = result.tokens;
        step.cost = result.cost;
        step.duration = Date.now() - startTime;

        // Store in context for next step
        chain.context.set(`step_${i}_output`, result.content);
        chain.context.set(`step_${i}_model`, step.model);

        results.push(result.content);

        if (onProgress) {
          onProgress(step);
        }

      } catch (error: any) {
        step.status = 'failed';
        step.output = error.message;
        
        if (onProgress) {
          onProgress(step);
        }

        throw new Error(`Chain failed at step ${i + 1}: ${error.message}`);
      }
    }

    return results[results.length - 1]; // Return final output
  }

  private interpolateContext(prompt: string, context: Map<string, any>): string {
    let result = prompt;
    
    context.forEach((value, key) => {
      result = result.replace(`{{${key}}}`, value);
    });

    return result;
  }

  private async executeStep(model: string, prompt: string): Promise<any> {
    // Call embedded server's /run/single endpoint
    const response = await fetch('http://127.0.0.1:3000/run/single', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model, prompt })
    });

    return await response.json();
  }
}
```

**Preset Chains:**

```typescript
// src/agents/presets.ts
export const CHAIN_PRESETS = {
  'refactor-comment-test': {
    name: 'Refactor + Comment + Test',
    steps: [
      {
        id: '1',
        name: 'Refactor Code',
        model: 'claude-3-opus-20240229',
        prompt: 'Refactor this code for better readability and performance:\n\n{{input}}'
      },
      {
        id: '2',
        name: 'Add Comments',
        model: 'gpt-4-turbo',
        prompt: 'Add comprehensive comments to this code:\n\n{{step_0_output}}'
      },
      {
        id: '3',
        name: 'Generate Tests',
        model: 'deepseek-coder',
        prompt: 'Generate unit tests for this code:\n\n{{step_1_output}}'
      }
    ]
  },

  'explain-optimize-document': {
    name: 'Explain + Optimize + Document',
    steps: [
      {
        id: '1',
        name: 'Explain Code',
        model: 'gemini-1.5-pro',
        prompt: 'Explain what this code does:\n\n{{input}}'
      },
      {
        id: '2',
        name: 'Optimize',
        model: 'deepseek-coder',
        prompt: 'Optimize this code:\n\n{{input}}\n\nExplanation:\n{{step_0_output}}'
      },
      {
        id: '3',
        name: 'Generate Docs',
        model: 'gpt-4-turbo',
        prompt: 'Write comprehensive documentation for:\n\n{{step_1_output}}'
      }
    ]
  },

  'multi-model-review': {
    name: 'Multi-Model Code Review',
    steps: [
      {
        id: '1',
        name: 'GPT-4 Review',
        model: 'gpt-4-turbo',
        prompt: 'Review this code for bugs and best practices:\n\n{{input}}'
      },
      {
        id: '2',
        name: 'Claude Review',
        model: 'claude-3-opus-20240229',
        prompt: 'Review this code for security and performance:\n\n{{input}}'
      },
      {
        id: '3',
        name: 'Synthesize Reviews',
        model: 'gemini-1.5-pro',
        prompt: 'Synthesize these reviews into actionable feedback:\n\nGPT-4: {{step_0_output}}\n\nClaude: {{step_1_output}}'
      }
    ]
  }
};
```

---

### 1.3 Chat Window UI

**Goal:** Persistent, dockable chat interface with context retention.

**Implementation:**

```typescript
// src/ui/chatPanel.ts
import * as vscode from 'vscode';

export class ChatPanel {
  private static currentPanel: ChatPanel | undefined;
  private readonly panel: vscode.WebviewPanel;
  private conversationHistory: Array<{role: 'user' | 'assistant', content: string, model?: string}> = [];
  private currentModel: string = 'gpt-4-turbo';

  public static show(context: vscode.ExtensionContext) {
    if (ChatPanel.currentPanel) {
      ChatPanel.currentPanel.panel.reveal();
      return;
    }

    const panel = vscode.window.createWebviewPanel(
      'hybridmindChat',
      'HybridMind Chat',
      vscode.ViewColumn.Two,
      {
        enableScripts: true,
        retainContextWhenHidden: true
      }
    );

    ChatPanel.currentPanel = new ChatPanel(panel, context);
  }

  private constructor(panel: vscode.WebviewPanel, context: vscode.ExtensionContext) {
    this.panel = panel;
    this.panel.webview.html = this.getHtmlContent();

    this.panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.command) {
          case 'sendMessage':
            await this.handleUserMessage(message.text);
            break;
          case 'changeModel':
            this.currentModel = message.model;
            break;
          case 'clearChat':
            this.conversationHistory = [];
            this.panel.webview.postMessage({ command: 'chatCleared' });
            break;
          case 'runChain':
            await this.handleChainExecution(message.chainType);
            break;
        }
      }
    );

    this.panel.onDidDispose(() => {
      ChatPanel.currentPanel = undefined;
    });
  }

  private async handleUserMessage(text: string) {
    // Add user message to history
    this.conversationHistory.push({ role: 'user', content: text });

    // Update UI
    this.panel.webview.postMessage({
      command: 'addMessage',
      role: 'user',
      content: text
    });

    // Show typing indicator
    this.panel.webview.postMessage({ command: 'typing', isTyping: true });

    try {
      // Send to AI with conversation context
      const response = await this.sendToAI(text);

      // Add assistant response
      this.conversationHistory.push({
        role: 'assistant',
        content: response.content,
        model: this.currentModel
      });

      // Update UI
      this.panel.webview.postMessage({
        command: 'addMessage',
        role: 'assistant',
        content: response.content,
        model: this.currentModel
      });

    } catch (error: any) {
      this.panel.webview.postMessage({
        command: 'error',
        message: error.message
      });
    } finally {
      this.panel.webview.postMessage({ command: 'typing', isTyping: false });
    }
  }

  private async sendToAI(userMessage: string): Promise<any> {
    // Build context from conversation history
    const messages = this.conversationHistory.map(msg => ({
      role: msg.role,
      content: msg.content
    }));

    // Add current message
    messages.push({ role: 'user', content: userMessage });

    // Call API
    const response = await fetch('http://127.0.0.1:3000/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: this.currentModel,
        messages: messages
      })
    });

    return await response.json();
  }

  private getHtmlContent(): string {
    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      font-family: var(--vscode-font-family);
      color: var(--vscode-foreground);
      background: var(--vscode-editor-background);
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #chat-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--vscode-panel-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #model-selector {
      background: var(--vscode-dropdown-background);
      color: var(--vscode-dropdown-foreground);
      border: 1px solid var(--vscode-dropdown-border);
      padding: 4px 8px;
      border-radius: 3px;
    }
    #chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }
    .message {
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
    }
    .message.user {
      justify-content: flex-end;
    }
    .message-bubble {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 8px;
      word-wrap: break-word;
    }
    .message.user .message-bubble {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
    }
    .message.assistant .message-bubble {
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
    }
    .model-badge {
      font-size: 0.75em;
      opacity: 0.7;
      margin-top: 4px;
    }
    #typing-indicator {
      display: none;
      padding: 8px;
      font-style: italic;
      opacity: 0.6;
    }
    #input-area {
      border-top: 1px solid var(--vscode-panel-border);
      padding: 12px 16px;
      display: flex;
      gap: 8px;
    }
    #message-input {
      flex: 1;
      background: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      padding: 8px 12px;
      border-radius: 4px;
      resize: none;
      font-family: inherit;
    }
    button {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: var(--vscode-button-hoverBackground);
    }
    #action-buttons {
      display: flex;
      gap: 4px;
      margin-top: 8px;
    }
    .action-btn {
      padding: 4px 8px;
      font-size: 0.85em;
    }
  </style>
</head>
<body>
  <div id="chat-header">
    <h3 style="margin: 0;">HybridMind Chat</h3>
    <select id="model-selector">
      <option value="gpt-4-turbo">GPT-4 Turbo</option>
      <option value="claude-3-opus-20240229">Claude 3 Opus</option>
      <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
      <option value="deepseek-coder">DeepSeek Coder</option>
      <option value="llama-3.3-70b">Llama 3.3 70B (Fast)</option>
    </select>
  </div>

  <div id="chat-container"></div>
  
  <div id="typing-indicator">AI is thinking...</div>

  <div id="input-area">
    <textarea 
      id="message-input" 
      placeholder="Ask anything..." 
      rows="2"
      onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendMessage();}"
    ></textarea>
    <button onclick="sendMessage()">Send</button>
  </div>

  <div id="action-buttons">
    <button class="action-btn" onclick="runChain('refactor-comment-test')">Refactor Chain</button>
    <button class="action-btn" onclick="runChain('multi-model-review')">Multi-Model Review</button>
    <button class="action-btn" onclick="clearChat()">Clear Chat</button>
  </div>

  <script>
    const vscode = acquireVsCodeApi();

    function sendMessage() {
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (!text) return;

      vscode.postMessage({ command: 'sendMessage', text });
      input.value = '';
    }

    function clearChat() {
      vscode.postMessage({ command: 'clearChat' });
      document.getElementById('chat-container').innerHTML = '';
    }

    function runChain(chainType) {
      vscode.postMessage({ command: 'runChain', chainType });
    }

    document.getElementById('model-selector').addEventListener('change', (e) => {
      vscode.postMessage({ command: 'changeModel', model: e.target.value });
    });

    window.addEventListener('message', event => {
      const message = event.data;
      
      if (message.command === 'addMessage') {
        addMessageToChat(message.role, message.content, message.model);
      } else if (message.command === 'typing') {
        document.getElementById('typing-indicator').style.display = 
          message.isTyping ? 'block' : 'none';
      } else if (message.command === 'error') {
        alert('Error: ' + message.message);
      }
    });

    function addMessageToChat(role, content, model) {
      const container = document.getElementById('chat-container');
      const messageDiv = document.createElement('div');
      messageDiv.className = \`message \${role}\`;
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = content;
      
      if (role === 'assistant' && model) {
        const badge = document.createElement('div');
        badge.className = 'model-badge';
        badge.textContent = model;
        bubble.appendChild(badge);
      }
      
      messageDiv.appendChild(bubble);
      container.appendChild(messageDiv);
      container.scrollTop = container.scrollHeight;
    }
  </script>
</body>
</html>`;
  }
}
```

---

## PHASE 2: PREMIUM FEATURES (Week 3-4)

### 2.1 Premium Model Gateway

```typescript
// src/models/premiumGateway.ts
export class PremiumModelGateway {
  private licenseManager: LicenseManager;

  private premiumModels = [
    'gpt-4-turbo',
    'gpt-4o',
    'claude-3-opus-20240229',
    'claude-3-5-sonnet-20240620',
    'gemini-1.5-pro',
    'qwen-max',
    'deepseek-coder'
  ];

  async routeRequest(model: string, prompt: string): Promise<any> {
    // Check if model requires premium
    if (this.premiumModels.includes(model)) {
      const hasPremium = await this.licenseManager.checkFeatureAccess('premium-models');
      
      if (!hasPremium) {
        throw new Error(
          `${model} requires HybridMind Pro. Upgrade at https://hybridmind.dev/pricing`
        );
      }
    }

    // Check context size
    if (prompt.length > 50000) {
      const hasLargeContext = await this.licenseManager.checkFeatureAccess('large-context');
      
      if (!hasLargeContext) {
        throw new Error(
          'Large context (>50k chars) requires HybridMind Pro'
        );
      }
    }

    // Route to appropriate model
    return await this.callModel(model, prompt);
  }

  private async callModel(model: string, prompt: string): Promise<any> {
    // Call embedded server
    const response = await fetch('http://127.0.0.1:3000/run/single', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model, prompt })
    });

    return await response.json();
  }
}
```

### 2.2 Fast Inference Router

```typescript
// src/optimization/fastRouter.ts
export class FastInferenceRouter {
  private fastModels = {
    'groq': ['llama-3.3-70b', 'mixtral-8x7b'],
    'deepseek': ['deepseek-chat', 'deepseek-coder'],
    'gemini-flash': ['gemini-1.5-flash']
  };

  selectFastModel(taskType: 'explain' | 'refactor' | 'test' | 'general'): string {
    // Route based on task type
    const routing = {
      'explain': 'gemini-1.5-flash',
      'refactor': 'deepseek-coder',
      'test': 'deepseek-coder',
      'general': 'llama-3.3-70b'
    };

    return routing[taskType] || 'llama-3.3-70b';
  }

  async executeWithFastFallback(model: string, prompt: string): Promise<any> {
    try {
      return await this.callModel(model, prompt);
    } catch (error: any) {
      // Fallback to fast model
      if (error.message.includes('timeout') || error.message.includes('rate limit')) {
        const fastModel = this.selectFastModel('general');
        return await this.callModel(fastModel, prompt);
      }
      throw error;
    }
  }
}
```

---

## PHASE 3: MONETIZATION (Week 5-6)

### 3.1 License Verification API

```typescript
// backend/routes/license.ts (separate Node.js API)
import express from 'express';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export const licenseRouter = express.Router();

licenseRouter.post('/verify', async (req, res) => {
  const { licenseKey } = req.body;

  try {
    // Verify license key in database
    const license = await db.licenses.findOne({ key: licenseKey });

    if (!license) {
      return res.json({ valid: false });
    }

    // Check if subscription is active
    if (license.stripeSubscriptionId) {
      const subscription = await stripe.subscriptions.retrieve(
        license.stripeSubscriptionId
      );

      if (subscription.status === 'active') {
        return res.json({
          valid: true,
          tier: 'pro',
          expiresAt: new Date(subscription.current_period_end * 1000)
        });
      }
    }

    return res.json({ valid: false });

  } catch (error) {
    res.status(500).json({ error: 'Verification failed' });
  }
});

licenseRouter.post('/create-checkout', async (req, res) => {
  const { email } = req.body;

  try {
    const session = await stripe.checkout.sessions.create({
      customer_email: email,
      line_items: [{
        price: process.env.STRIPE_PRICE_ID!, // $19/month
        quantity: 1
      }],
      mode: 'subscription',
      success_url: 'https://hybridmind.dev/success?session_id={CHECKOUT_SESSION_ID}',
      cancel_url: 'https://hybridmind.dev/pricing'
    });

    res.json({ sessionId: session.id, url: session.url });

  } catch (error) {
    res.status(500).json({ error: 'Checkout failed' });
  }
});

// Stripe webhook for subscription events
licenseRouter.post('/webhook', async (req, res) => {
  const event = req.body;

  if (event.type === 'customer.subscription.created') {
    // Generate license key
    const licenseKey = generateLicenseKey();
    
    await db.licenses.create({
      key: licenseKey,
      email: event.data.object.customer_email,
      stripeSubscriptionId: event.data.object.id,
      tier: 'pro',
      createdAt: new Date()
    });

    // Email license key to customer
    await sendLicenseEmail(event.data.object.customer_email, licenseKey);
  }

  if (event.type === 'customer.subscription.deleted') {
    // Revoke license
    await db.licenses.updateOne(
      { stripeSubscriptionId: event.data.object.id },
      { $set: { active: false } }
    );
  }

  res.json({ received: true });
});
```

### 3.2 Landing Page Integration

```html
<!-- landing-page/index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>HybridMind - Premium AI Coding Assistant</title>
  <script src="https://js.stripe.com/v3/"></script>
</head>
<body>
  <section class="hero">
    <h1>HybridMind</h1>
    <p>The Multi-Model AI Coding Assistant</p>
    
    <div class="cta-buttons">
      <a href="https://marketplace.visualstudio.com/items?itemName=hybridmind.hybridmind" 
         class="btn btn-primary">
        Start Free
      </a>
      <button onclick="startCheckout()" class="btn btn-secondary">
        Get Pro - $19/month
      </button>
    </div>
  </section>

  <section class="pricing">
    <div class="tier">
      <h3>Free</h3>
      <ul>
        <li>Basic models</li>
        <li>Single-step completions</li>
        <li>Standard speed</li>
      </ul>
      <a href="https://marketplace.visualstudio.com/items?itemName=hybridmind.hybridmind">
        Install Free
      </a>
    </div>

    <div class="tier featured">
      <h3>Pro - $19/month</h3>
      <ul>
        <li>âœ¨ All premium models (GPT-4, Claude, Gemini)</li>
        <li>ðŸ¤– Agentic workflows</li>
        <li>ðŸ’¬ Persistent chat window</li>
        <li>âš¡ Fast inference (Groq, DeepSeek)</li>
        <li>ðŸ“š 128k context windows</li>
        <li>ðŸŽ¯ Priority support</li>
        <li>ðŸ”¬ Early access features</li>
      </ul>
      <button onclick="startCheckout()">Get Started</button>
    </div>
  </section>

  <script>
    async function startCheckout() {
      const email = prompt('Enter your email:');
      if (!email) return;

      const response = await fetch('https://api.hybridmind.dev/license/create-checkout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      });

      const { url } = await response.json();
      window.location.href = url;
    }
  </script>
</body>
</html>
```

---

## PHASE 4: IMPLEMENTATION ROADMAP

### Week 1-2: Foundation
- [ ] Implement LicenseManager
- [ ] Add license verification API
- [ ] Update extension settings for license key
- [ ] Create basic ChainEngine
- [ ] Implement 3 preset chains

### Week 3-4: Premium Features
- [ ] Build ChatPanel UI
- [ ] Implement conversation context
- [ ] Add PremiumModelGateway
- [ ] Build FastInferenceRouter
- [ ] Add cost estimators

### Week 5-6: Monetization
- [ ] Set up Stripe account
- [ ] Build license verification backend
- [ ] Create landing page
- [ ] Implement payment flow
- [ ] Add webhook handlers

### Week 7-8: Polish & Launch
- [ ] Add telemetry
- [ ] Build analytics dashboard
- [ ] Create documentation
- [ ] Beta test with 10 users
- [ ] Public launch

---

## TECHNICAL SPECIFICATIONS

### API Endpoints (Embedded Server)

```typescript
// New endpoints to add to embeddedServer.ts

// Chat endpoint with context
app.post('/chat', async (req, res) => {
  const { model, messages } = req.body;
  // Handle multi-turn conversation
});

// Chain execution endpoint
app.post('/chain/execute', async (req, res) => {
  const { chainId, steps, input } = req.body;
  // Execute agentic chain
});

// License verification
app.post('/license/verify', async (req, res) => {
  const { licenseKey } = req.body;
  // Call external license API
});
```

### File Structure

```
hybridmind-extension/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ licenseManager.ts
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ chainEngine.ts
â”‚   â”‚   â””â”€â”€ presets.ts
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â”œâ”€â”€ chatPanel.ts
â”‚   â”‚   â””â”€â”€ chainProgressView.ts
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ premiumGateway.ts
â”‚   â”œâ”€â”€ optimization/
â”‚   â”‚   â””â”€â”€ fastRouter.ts
â”‚   â””â”€â”€ extension.ts
â”œâ”€â”€ backend/  (separate Node.js API)
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â””â”€â”€ license.ts
â”‚   â””â”€â”€ server.ts
â””â”€â”€ landing-page/
    â””â”€â”€ index.html
```

---

## COST & REVENUE PROJECTIONS

### Costs (Monthly)
- Stripe fees: 2.9% + $0.30 per transaction
- Server hosting (Vercel/Railway): $20-50
- License API (Railway): $20
- Email (SendGrid): $15
- **Total:** ~$60-100/month

### Revenue Targets
- 50 Pro users: $950/month
- 100 Pro users: $1,900/month
- 500 Pro users: $9,500/month
- 1,000 Pro users: $19,000/month

### Break-even: 6-8 Pro subscribers

---

## LAUNCH CHECKLIST

- [ ] Extension v1.1 feature-complete
- [ ] License verification working
- [ ] Stripe integration tested
- [ ] Landing page live
- [ ] Payment flow tested end-to-end
- [ ] Email automation working
- [ ] Analytics tracking implemented
- [ ] Documentation complete
- [ ] Beta tested with 10+ users
- [ ] Support system ready
- [ ] Marketing materials prepared
- [ ] VS Code Marketplace listing updated

---

**This is your complete architecture for HybridMind v1.1. Ready to implement?**
